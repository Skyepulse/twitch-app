import fs from 'fs';
import path from 'path';

//==============TRIVIA==================//
// We tackle the randon maze generation problem
// of an n x m grid by using graph theory.
//
// " A maze can be generated by starting with a predetermined arrangement
//  of cells (most commonly a rectangular grid but other arrangements are possible) 
// with wall sites between them. This predetermined arrangement can be considered as a 
// connected graph with the edges representing possible wall sites and the nodes representing cells. 
// The purpose of the maze generation algorithm can then be considered to be making a subgraph in which 
// it is challenging to find a route between two particular nodes.
// If the subgraph is not connected, then there are regions of the graph that are wasted 
// because they do not contribute to the search space. If the graph contains loops, 
// then there may be multiple paths between the chosen nodes. Because of this, maze 
// generation is often approached as generating a random spanning tree. Loops, 
// which can confound naive maze solvers, may be introduced by adding random edges to 
// the result during the course of the algorithm."
//
// Source: https://en.wikipedia.org/wiki/Maze_generation_algorithm
//================================//

// I choose the recursive BackTracking algorithm to generate the maze

//===============Constants=================//
const N = 1, S = 2, E = 4, W = 8;
const DX: { [key: number]: number } = { [E]: 1, [W]: -1, [N]: 0, [S]: 0 };
const DY: { [key: number]: number } = { [E]: 0, [W]: 0, [N]: -1, [S]: 1 };
const OPPOSITE: { [key: number]: number } = { [E]: W, [W]: E, [N]: S, [S]: N };

//===============Members=================//
let grid: number[][] = [];
let visitOrder: number[][] = [];
let currentVisitOrder: number = 1;

//================================//
const InitializeGrid = (width: number, height: number): void => {
    grid = Array.from({ length: height }, () => Array(width).fill(0));
    visitOrder = Array.from({ length: height }, () => Array(width).fill(0));
    currentVisitOrder = 1;
}

//================================//
const CarvePassageFrom = (currentRow: number, currentColumn: number): void => { 
    visitOrder[currentRow][currentColumn] = currentVisitOrder
    currentVisitOrder++; 

    // Random directions
    const directions = [N, S, E, W].sort(() => Math.random() - 0.5);

    directions.forEach((dir) => {
        const nextTile: [number, number] = [currentRow + DY[dir], currentColumn + DX[dir]];
        if (IsValidTile(nextTile)) {
            if (currentRow === 0 && currentColumn === 0) {
                console.log(dir, OPPOSITE[dir]);
            }
            const [nextRow, nextColumn] = nextTile;
            grid![currentRow][currentColumn] |= dir;
            grid![nextRow][nextColumn] |= OPPOSITE[dir];
            CarvePassageFrom(nextRow, nextColumn);
        }
    });
}

//================================//
const IsValidTile = ([row, column]: [number, number]): boolean => {
    if (!grid || grid.length === 0) return false;
    return row >= 0 && row < grid.length && column >= 0 && column < grid[0].length && grid[row][column] === 0;
}

//================================//
const ShowMaze = (grid: number[][]): void => {
    if (!grid || grid.length === 0) {
        console.error("Maze grid is empty, nothing to display.");
        return;
    }

    let mazeString = '';
    const height = grid.length;
    const width = grid[0].length;

    mazeString += width + ' ' + height + '\n';

    const totalCells = width * height;
    const padding = Math.floor(Math.log10(totalCells)) + 1;

    for (let row = 0; row < height; row++) {
        for (let column = 0; column < width; column++) {
            mazeString += grid[row][column].toString().padStart(padding, '0') + ' ';
        }
        mazeString += '\n';
    }

    mazeString += '\n';
    for (let row = 0; row < height; row++) {
        for (let column = 0; column < width; column++) {
            mazeString += visitOrder[row][column].toString().padStart(padding, '0') + ' ';
        }
        mazeString += '\n';
    }

    // Save to file
    const mazePath = path.resolve(process.cwd(), 'frontend/public/maze.txt');
    try {
        fs.writeFileSync(mazePath, mazeString);
        console.log(`Maze saved to ${mazePath}`);
    } catch (error: any) {
        console.error(`Error saving maze: ${error.message}`);
    }
}

//================================//
const GenerateRandomMaze = (width: number, height: number, verbose: boolean = false): number[][] => {
    InitializeGrid(width, height);
    CarvePassageFrom(0, 0);
    if (verbose) {
        ShowMaze(grid!);
    }
    return grid!;
}

//================================//
GenerateRandomMaze(25, 40, true);